import CodeBlock from '../../components/codeBlock';
import CodePannel from '../CodePannel';
import HighlightText from '../HighlightText';

## 增删改查
**unshift开头插入-splice也可以实现**

export const arrUnshift1 = `
// unshift -> array <- push
const testArr = [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }]
// 并返回新的长度
console.log('当前长度：', testArr.unshift({ id: 66 }))
console.log('testArr：', testArr)

// splice也可以实现
const arrSplice = [2, 3, 4, 5];
const element = 1;
arrSplice.splice(0, 0, element)
console.log('splice也可以实现:',arrSplice);
`

<CodePannel code={arrUnshift1} name='arrUnshift1' height='300px' />

<HighlightText>
**shift删除第一个元素/pop删除最后一个元素**
</HighlightText>
删除第一个元素，并返回删除元素的值。shift 可以模拟队列出

export const arrShft1 = `
const testArr = [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }]

console.log('删除元素的值：', testArr.shift())
console.log('testArr：', testArr)

console.log('<============>删除数组的最后一个元素并返回删除的元素:')
const testArr2 = [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }]
console.log('删除元素的值：', testArr2.pop())
console.log('testArr删除之后：', testArr2)
`

<CodePannel code={arrShft1} name='arrShft1' height='300px' />


<HighlightText>
splice任意位置删除
</HighlightText>

export const arrSplice1 = `
const testArr = [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }]
const testArr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 参数：参数1：索引值，参数2：个数(如果不是删除穿0)，第三个参数往后，需要添加到数组的元素
// 从数组索引5开始，一共删除3个元素，并返回删除的元素
console.log(testArr2.splice(5, 3))
console.log('testArr：', testArr2)

// 使用方法2：删除指定下标的元素
console.log(testArr.splice(2, 1));
console.log('testArr：', testArr)


// test: 删除空数组
const testArr3 = []
testArr3.splice(1,1)
console.log('testArr3:',testArr3)
`

<CodePannel code={arrSplice1} name='arrSplice1' height='400px' />

<HighlightText>
slice返回一个新数组,不改变原数组
</HighlightText>

slice(start,end) 参数有两个，start为必填字段，end为选填字段，返回一个新的数组，包含从 start 到 end 的元素。

<CodeBlock>
```js
const fruits = ['apple', 'banana', 'mango', 'orange'];

const slicedFruits = fruits.slice(1, 3);
// slicedFruits 现在是 ['banana', 'mango']

console.log(fruits);
// fruits 仍然是 ['apple', 'banana', 'mango', 'orange']
```
</CodeBlock>


<HighlightText>
slice该方法也用于字符串
</HighlightText>
start 要抽取的片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。
也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。

end	紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。
如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。

export const arrSlice1 = `
// 应用于string
const str = "abcdefg";
console.log(str.slice(-1)); // g
console.log(str.slice(2)); // cdefg
console.log(str.slice(0, 3)); // abc
console.log(str.slice(0, -2)); // abcde
console.log(str.slice(-3, -2)); // e

// 应用于数组
const testArr = [0, 1, 2, 3, 4, 5]
console.log(testArr.slice(1, 3)); // [1, 2]
console.log(testArr.slice(0, 3)); // [0,1, 2]

// 应用：字符串反转
function reverse(str) {
    if (str.length === 1) {
        return str;
    }
    return str.slice(-1) + reverse(str.slice(0, -1));
}
const testStr = "helloworld";
console.log('字符串反转:', reverse(testStr)); // dlrowolleh
`

<CodePannel code={arrSlice1} name='arrSlice1' height='400px' />

## 01-array.join把数组转化为string

export const arrJoin1 = `
const testArr = new Array(0, 1, 2, 3, 4);
console.log('to string1:', testArr.join(""))
console.log('to string2:', testArr.join("-"))
/*
to string1: 01234
to string2: 0-1-2-3-4
* */

// 带引号
const symbols = ["BTCUSDT", "BNBUSDT"]
console.log(symbols.join(','))
`

<CodePannel code={arrJoin1} name='arrJoin1' height='200px' />

## 02.str.split()
* 教训: 以为字符分割不能是 空字符串

export const arrS2 = `
let testStr = '  hello world  ';
console.log(testStr.split(' '))
`

<CodePannel code={arrS2} name='arrS2' height='200px' />

## 03-filter-过滤函数
并不会改变原始数组，而是返回一个新数组

Array.filter(function(currentValue, index, arr), thisValue)

callback:用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。
```
它接受以下三个参数：
    element数组中当前正在处理的元素。

    index可选,正在处理的元素在数组中的索引filter。

    array可选,调用了 filter 的数组本身。

    thisArg可选,执行 callback 时，用于 this 的值。
```


export const arrFilter1 = `
const arrays = [
    { id: 1 },
    { id: 2 },
    { id: 3 },
    { id: 4 },
]

console.log(arrays.filter(item => item.id !== 1))

// 2.使用：去重
const unique = (arr) => {
    return arr.filter((item, index) => arr.indexOf(item) === index);
}
const arr = ['apple', 'banana', 'apple', 'pear', 'strawberry'];
console.log(unique(arr));

// 3.进阶：配合findIndex 使用
let array1 = [1, 3];
let array2 = [
    { id: 1, label: "tes1" },
    { id: 2, label: "tes2" },
    { id: 3, label: "tes3" },
    { id: 4, label: "tes3" },
];

let targetArr = array2.filter((ele) => {
    return (
        -1 !==
        array1.findIndex((item) => {
            console.log("item:", item);
            return item === ele.id;
        })
    );
});

console.log("进阶：配合findIndex 使用:", targetArr);
`

<CodePannel code={arrFilter1} name='arrFilter1' height='500px' />

## 04-find-返回第一个满足条件的是对象/findIndex
export const arrFind1 = `
const testArr = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }, { id: 3, name: '王五' }, { id: 2, name: '赵六' }]

console.log(testArr.find((item) => item.id === 3))

// 2.
const testArr1 = [20, 12, 362, 26, 965, 22, 26, 35];

const findItem1 = testArr1.find(function (item, index, arr) { return item > 26 });

console.log('test 2:', findItem1) // 362
`

<CodePannel code={arrFind1} name='arrFind1' height='300px' />

### 04-2. findIndex()为数组中的每个元素都调用一次函数执行：
ES6新增, 当数组中的元素在测试条件时返回 true 时,findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。

如果没有符合条件的元素返回 -1

**findIndex 和 indexOf 对比**
* 1.findIndex()和indexOf方法实现都是通过循环遍历查找。
* 2.findIndex()的应用场景要比indexOf广泛一些，可以查找大于等于小于，表达式可以随便写，
indexOf就只能在第一层查找相等的值。
findIndex是传入一个测试条件,也就是函数,找到了返回当前项索引,没有找到返回-1

* 3.findIndex()实际上相当于一个for循环，只不过找到了你不需要自己退出。
* 4.indexOf是判断数组中某个元素是否存在,不存在则返回-1
* 5.findIndex是用来查找索引的,返回的查找到的符合项的索引.

<CodeBlock>
```js
const testArr = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }, { id: 3, name: '王五' }, { id: 2, name: '赵六' }]

const arrIndex = testArr.findIndex(item => {
    return item.name === '张三';
});

if (arrIndex > -1) {
    console.log("包含", testArr[arrIndex]);
} else {
    console.log("不包含");
}
```
</CodeBlock>


### indexOf()
indexOf() 方法可返回数组中某个指定的元素位置。

该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。

如果在数组中没找到指定元素则返回 -1。

export const arrIndexOf1 = `
const target = '5'

let arr = ['1', '2', '3', '4']
let arrIndex = arr.indexOf(target)

if (arrIndex > -1) {
  console.log("包含");
  arr.splice(arrIndex, 1)
} else {
  console.log("不包含");
  arr.push(target)
}

console.log('操作之后:', arr)

/*
* test 2
* */
const testArr = [20, 12, 362, 26, 965, 22, 26, 35];
const index1 = testArr.indexOf(26);

console.log('test 2:', index1) //3
`

**lastIndexOf()和arr.indexOf()的功能一样，不同的是从后往前查找**
<CodeBlock>
```js
let arr = [1, 2, 3, 4, 5, 2]
let arr1 = arr.lastIndexOf(2)
console.log(arr1)  // 5
let arr2 = arr.lastIndexOf(9)
console.log(arr2)  // -1
```
</CodeBlock>

<CodePannel code={arrIndexOf1} name='arrIndexOf1' height='300px' />

## 05.includes() / some() /every
<HighlightText>
**1.includes用来判断一个数组是否包含一个指定的值，有则返回 true，否则返回false**
</HighlightText>

<HighlightText>
**2.some()依据判断条件，数组的元素是否有一个满足，若有一个满足则返回true**
</HighlightText>

some方法可以提供更复杂的条件逻辑，例如检查数组中的元素是否满足某个条件，或仅检查数组中任何一个元素是否等于某个特定值。 而include方法仅仅检查数组中是否包含某个特定的值。


<HighlightText>
**3.every-所有满足则返回true**
</HighlightText>
every 对数组中的每个元素运行给定函数，如果该函数对每个元素都返回true，则返回true

export const arrSome1 = `
// includes
console.log('includes',[1, 2, 3].includes(2)); // true

// some
const data = [
  {
    "assemblyInfo": {
        "id": "YxSpellGroup",
        "iconType": "iconshangpintuijian",
        "title": "拼团",
        "onlyCode": 539187388
    },
    "assemblyParam": {}
  },
  {
    "assemblyInfo": {
        "id": "YxPages",
        "iconType": "iconshangpintuijian",
        "title": "拼团",
        "onlyCode": 539187388
    },
    "assemblyParam": {}
  },
];

// 使用Array.some()方法检查数组中是否存在满足条件的元素
const containsYxPages = data.some(item => item.assemblyInfo.id === 'YxPages');

if (containsYxPages) {
  console.log('包含assemblyInfo = YxPages的元素');
} else {
  console.log('不包含assemblyInfo = YxPages的元素');
}

// every
const isEven = x => x % 2 === 0;
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];

console.log('every:numbers.every(isEven)', numbers.every(isEven)); // false
`

<CodePannel code={arrSome1} name='arrSome1' height='400px' />

## 09-map-生成新数组-数组转map结构
在forEach中return语句是没有任何效果的，而map则可以改变当前循环的值

返回一个新的被改变过值之后的数组（map需return），

一般用来处理需要修改某一个数组的值。
```
callback的参数:
        value --当前索引的值
        index --索引
        array --原数组
```

export const arrMap1 = `
let testArr1 = [1, 2, 3];
let testArr2 = testArr1.map((value, key, arr) => {
    console.log(value)    // 1，2，3
    console.log(key)      // 0，1，2
    console.log(arr)      //[1,2,3] [1,2,3] [1,2,3]
    return value * value;
})

console.log('原数组:', testArr1); // [ 1, 2, 3 ]
console.log('map后：', testArr2); // [ 1, 4, 9 ]
`

<CodePannel code={arrMap1} name='arrMap1' height='300px' />

## 09-2.数组转map
export const arrMap2 = `
const arr = [
  // 2023年4月 价格，现在是202409，6w
  { symbol: 'BTCUSDT', price: '23147.08000000' },
  { symbol: 'BNBUSDT', price: '312.90000000' },
  { symbol: 'ZENUSDT', price: '10.21000000' },
  { symbol: 'DOTUSDT', price: '6.27800000' },
  { symbol: 'OGUSDT', price: '2.77100000' },
  { symbol: 'SHIBUSDT', price: '0.00001186' },
  { symbol: 'APTUSDT', price: '16.97200000' }
]

const map = new Map(arr.map(item=>[item.symbol,item.price]))

console.log('map:',map)
console.log('map:',map.get('BTCUSDT'))
`

<CodePannel code={arrMap2} name='arrMap2' height='300px' />

## 10-sort-采用快排和插入排序算法
**会改变原始数组。它会按照升序或降序重新排列数组元素，并返回已排序的数组。**

不想更改原始数组，可以通过创建一个副本来排序该副本

**比较规则：**
- 返回一个负数，第一个参数应该位于第二个参数的前面-->不需要替换
- 返回一个正数,第一个参数应位于第二个参数的之后-->需要替换
- 两个参数相等，则返回 0，

默认是将数组元素转为字符串，然后根据 Unicode 字符集编号的大小排序。

charCodeAt(index) 返回指定位置字符的 Unicode 编号，取值是 0 - 65535 间的整数，
与 charAt() 方法执行的操作相似，后者返回的是单个字符。

如果不提供比较器而对数字组成的数组排序，因为会将数字转为字符串再按编号排序而导致错误。
要获得正确的顺序，只需提供比较器函数：
```js
function(a,b){
  return a-b;
}
```

export const arrSort1 = `
let testArr = [6, 9, 2, 5];

const newArr = testArr.sort((a, b) => {
  console.log("", a, b);
  // debugger;
  if (a - b < 0) {
    // 在排序后的数组中 a 应该出现在 b 之前,则返回一个小于 0 的值。
    console.log("负数数不需要交换", "a:", a, "b:", b);
  } else {
    console.log("正数要交换", "a:", a, "b:", b);
  }
  return a - b;
});

console.log("升序：", newArr); //[2, 5, 6, 9]

let testArr2 = [6, 9, 2, 5];
console.log(
  "降序：",
  testArr2.sort((a, b) => b - a)
); // [9, 6, 5, 2]


console.log('<============>数字排序:')
const numbers2 = [1, 3, 3, 4, -1, 6, 7, 8, -2, 10, 11, 12, 13, 14, 15];
const res = numbers2.sort((a, b) => a - b);
console.log("使用sort进行数组排序:numbers.sort((a, b) => a - b)", res);
// [-2, -1, 1, 3, 3, 4, 6, 7, 8, 10, 11, 12, 13, 14, 15]

console.log('<============>字符串排序:')
const arrStr = ["eeeee", "b", "bccc", "accc", "afff"];
console.log(
  "字符串排序：",
  arrStr.sort((a, b) => {
    return a > b ? 1 : -1;
  })
);

// ['accc', 'afff', 'b', 'bccc', 'eeeee']


console.log('<============>对象排序:')
const friends = [
  { name: "John", age: 30 },
  { name: "Ana", age: 20 },
  { name: "Chris", age: 25 },
];

function comparePerson(a, b) {
  if (a.age < b.age) {
    return -1;
  }
  if (a.age > b.age) {
    return 1;
  }
  return 0;
}

console.log(
  "对象排序：friends.sort(comparePerson)",
  friends.sort(comparePerson)
);
`

<CodePannel code={arrSort1} name='arrSort1' height='400px' />

## arr.reduce(callback, initialValue)
通常我们会传递两个参数给这个函数：一个在每一次规约过程中都会被调用的函数和一个初始值。在每一次调用函数的过程中，函数会返回一个值，这个值会和下一次调用函数时的第一个参数进行计算，直到最后一个元素被处理完。最后，reduce() 方法返回规约后的最终值。

迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值
```
参数：callback:
          previousValue 必选 --上一次调用回调返回的值，或者是提供的初始值（initialValue）
          currentValue 必选 --数组中当前被处理的数组项
          index 可选 --当前数组项在数组中的索引值
          array 可选 --原数组
     initialValue: 可选 --初始值

实行方法：回调函数第一次执行时，preValue 和 curValue 可以是一个值，如果 initialValue 在调用 reduce() 时被提供，
```

那么第一个 preValue 等于 initialValue ，并且curValue 等于数组中的第一个值；
如果initialValue 未被提供，那么preValue 等于数组中的第一个值.

export const arrReduce1 = `
// 例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。
let arrA = [0, 1, 2, 3, 4]
let arr1 = arrA.reduce((preValue, curValue, index, arr) => {
    console.log('数组求和:',preValue, curValue, index);
    return preValue + curValue
})

console.log('数组求和结果：',arr1)    // 10

console.log('<============>')
const arr2 = [1, 2, 3, 4];
const mul = arr2.reduce((x, y) => x * y)
console.log('求乘积:', mul); //求乘积，24

console.log('<============>','reduce的高级用法: 1.计算数组中每个元素出现的次数')

let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
let nameNum = names.reduce((pre, cur) => {
    if (cur in pre) {
        pre[cur]++
    } else {
        pre[cur] = 1
    }
    return pre
}, {})

console.log('计算数组中每个元素出现的次数:', nameNum); 
//{Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}

console.log('<============>数组去重')
let arr3 = [1, 2, 3, 4, 4, 1]
let newArr = arr3.reduce((pre, cur) => {
    if (!pre.includes(cur)) {
        return pre.concat(cur)
    } else {
        return pre
    }
}, [])
console.log('数组去重:',newArr);// [1, 2, 3, 4]


console.log('<============>对象里的属性求和')
const result = [
    {
        subject: 'math',
        score: 10
    },
    {
        subject: 'chinese',
        score: 20
    },
    {
        subject: 'english',
        score: 30
    }
];

const sum = result.reduce(function (prev, cur) {
    return cur.score + prev;
}, 0);

console.log('对象里的属性求和:',sum) // 60
`

***
<CodeBlock>
```js
const initializedData2 = [];
for (let i = 0; i < rows.length; i++) {
  const row = rows[i];
  const rowData = {};

  if (rowKeys.includes(row.id)) {
    for (let j = 0; j < columns.length; j++) {
      const col = columns[j];

      const cell = cells.find(
        (c) => c.props.columnId === col.id && c.props.rowId === row.id,
      )!;

      // console.log('%c=ceelllll', 'color:red', cell);

      rowData[col.id] = cell;
    }
    initializedData2.push(rowData);
  }
}

const initializedData2 = rows.reduce((acc:Record<string, ICellNode>[], row) => {
  if (rowKeys.includes(row.id)) {
    const rowData = columns.reduce((rowData, col) => {
      const cell = cells.find(
        (c) => c.props.columnId === col.id && c.props.rowId === row.id,
      )!;

      rowData[col.id] = cell;
      return rowData;
    }, {} as Record<string, ICellNode>);

    acc.push(rowData);
  }

  return acc;
}, []);
```
</CodeBlock>

<CodePannel code={arrReduce1} name='arrReduce1' height='600px' />

## values:遍历数组键值/entries-遍历数组的键名和键值

export const arrValuesAndEntries = `
// arr.values() 遍历数组键值
let arr = [1, 2, 3, 4]
let arr1 = arr.values()
for (let val of arr1) {
  console.log(val); // 1,2,3,4
}

// 迭代数组中每个值前一个是索引值作为key，数组后一个值作为value
let arr2 = arr.entries()
console.log('arr2:',arr2)
for (let e of arr2) {
  console.log(e);   // [0,1] [1,2] [2,3] [3,4]
}
`

<CodePannel code={arrValuesAndEntries} name='arrValuesAndEntries' height='400px' />
