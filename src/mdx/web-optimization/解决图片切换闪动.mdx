## unoptimized 和 priority

```jsx
import Image from "next/image";

<Image
  src={`${ImageBaseUrl}${item.icon}/public`}
  alt={`banner-${idx}`}
  fill
  className="transition-opacity duration-700"
  unoptimized={true}
  priority={true}
/>
```

- 之前没加 unoptimized 和 priority，在静态导出场景下，构建可能出错，浏览器可能每次都请求图片；
- 加了这两个属性后，静态导出可用，浏览器会复用缓存，不会每次请求。
```html
<img alt="banner-2" decoding="async" data-nimg="fill" src="https://imagedelivery.net/i6ZQsk8NXHyvnNh4w9Qu_A/cd79d07c-61d4-48a7-e366-9e56f6cb6b00/public">

<img alt="banner-2" loading="lazy" decoding="async" data-nimg="fill" src="https://imagedelivery.net/i6ZQsk8NXHyvnNh4w9Qu_A/65e2d355-6bfa-4fde-2f38-e322d4401600/public">



非nextjs 渲染出来的， 这样的图片是加了？ priority？
<img data-v-c1e98f1f="" class="w-full h-full rounded-[.625rem]" src="https://upload-us.f-1-g-h.com/s2/1766460394748/VIP.gif"> 

不是。这个 <img> 既没有 priority，也不是 Next.js <Image> 生成的。

priority 是 Next.js <Image> 的概念

原生 <img> 默认行为是： loading = eager（立即加载）,你这个 GIF 没加 priority，但行为上等价于 priority
那为什么它“看起来不闪”？
因为它本质上已经是 priority 行为 了
```

| 项目        | 加了 `priority`    | 没加            |
| --------- | ---------------- | ------------- |
| `loading` | **默认 eager（立即）** | `lazy`        |
| 加载时机      | HTML 解析到就加载      | 进入视口才加载       |
| 页面切换回来    | **几乎瞬间显示**       | 可能有延迟 / 闪一下   |
| 网络请求      | **是否请求由缓存决定**    | **是否请求由缓存决定** |

## priority 只影响「加载时机」，不影响「缓存复用」
用一句技术人能记住的话总结
```
lazy 图片即使在缓存中，也可能“晚解码”
priority 图片即使没缓存，也会“提前解码”
```

- 没加 priority（默认 loading="lazy"）
```
页面切换
↓
<img> 被插入 DOM（但 lazy）
↓
浏览器：等等…先不加载
↓
元素进入视口
↓
才开始请求 / 解码
↓
图片出现
```

- 加了 priority 发生了什么？
```
页面开始切换
↓
浏览器在解析 HTML 阶段
↓
已经开始下载图片（eager）
↓
React 挂载 <img>
↓
图片数据已在内存 / 已解码
↓
直接显示
```

### 什么时候一定要用 priority？
- ✔ Banner
- ✔ 轮播图首张
- ✔ 页面切换马上可见的图片
- ✔ “不能闪”的视觉核心元素

🚫 列表图 / 非首屏
🚫 大量图片（会抢带宽）

### 流程
一、❌ 没加 priority（默认 loading="lazy"）

即使图片已经在浏览器缓存里，也可能闪
```
时间 →
┌──────────────────────────────────────────────┐
│ 1. 页面开始切换                               │
│                                              │
│ 2. React 渲染组件                             │
│    <img loading="lazy"> 被插入 DOM            │
│                                              │
│ 3. 浏览器：这是 lazy，先不管                  │
│    （哪怕缓存里已经有图片）                  │
│                                              │
│ 4. IntersectionObserver 判断进入视口          │
│                                              │
│ 5. 才开始：                                 │
│    - 读取缓存 / 发请求                        │
│    - 解码图片                                 │
│                                              │
│ 6. 图片绘制到屏幕                             │
│                                              │
│ ❗ 2 → 6 之间 = 空白 / 占位 / 闪一下           │
└──────────────────────────────────────────────┘
```
关键点（很多人不知道）
- 缓存 ≠ 已解码
- lazy 图片在进入视口前：
    - 不解码
    - 不绘制

所以你会看到： 「明明加载过，为什么切回来还闪？」

二、✅ 加了 priority={true}

不是不请求，而是“来得及”
```
时间 →
┌──────────────────────────────────────────────┐
│ 1. 页面开始切换                               │
│                                              │
│ 2. 浏览器解析 HTML / React Tree               │
│    发现 priority 图片                         │
│                                              │
│ 3. 立即进入关键资源队列                      │
│    - 如果缓存存在 → 立即读取                  │
│    - 同时提前解码                             │
│                                              │
│ 4. React 插入 <img> 到 DOM                    │
│                                              │
│ 5. 图片数据已准备好                           │
│    → 直接绘制                                │
│                                              │
│ ✅ DOM 出现 = 图片出现                         │
│ ✅ 没有空窗期                                 │
└──────────────────────────────────────────────┘
```

## 真实面试场景里，你已经赢了

如果你在面试中说出这些话：
```
“图片切换闪动不是重新请求，是 lazy 导致解码延迟，
priority 的作用是提前进入 decode pipeline。”
```

80% 面试官会直接点头。
20% 会追问你 CLS / LCP。

一句话先给结论
- CLS 和 LCP 是衡量“页面体验是否专业”的核心指标
- 而你刚才讨论的 priority / 闪动 / lazy，正好全部命中它们

## 一、LCP（Largest Contentful Paint）是什么？
中文：最大内容绘制时间

用户看到“页面主体内容”的时间点

通常是以下之一：
- Banner 大图
- 首屏 Hero Image
- 首屏最大文字块

| LCP 时间    | 体验 |
| --------- | -- |
| ≤ 2.5s    | 好  |
| 2.5s ~ 4s | 一般 |
| > 4s      | 差  |

“为什么 priority 能消闪？”
这正是 LCP 优化手段之一。

## 二、CLS（Cumulative Layout Shift）是什么？
中文：累计布局偏移

页面在加载过程中，元素跳来跳去的程度

典型场景：
- 图片加载后把文字顶下去

- Banner 高度变化

- 列表抖动

| CLS 值      | 体验 |
| ---------- | -- |
| ≤ 0.1      | 好  |
| 0.1 ~ 0.25 | 一般 |
| > 0.25     | 差  |

你反复提到的： 99% 就是 CLS 在作祟
- “闪一下”
- “切换页面抖一下”

| 原因            | CLS |
| ------------- | --- |
| 图片没占位         | ❌ 高 |
| 宽高未知          | ❌ 高 |
| fill + 父容器无高度 | ❌ 高 |

三、把你现在的 Image 场景串起来（关键）

你现在做的其实是 LCP + CLS 的组合优化。

### 高分回答模板（你可以直接用）
“我会先识别首屏 LCP 元素，通常是 banner 图，
这类图片必须 eager 加载，用 priority。
同时我会保证图片有明确尺寸或稳定容器，避免布局偏移。
非首屏图片才 lazy，防止抢带宽。”

## 用一句“工程师级”的话总结
- lazy 是「先 DOM，后图片」
```
时间 ─────────────────────────────────────────▶

DOM 挂载   |───────[ img 插入 DOM ]────────────|
请求       |───────────────[ 请求 ]────────────|
解码       |──────────────────────[ 解码 ]─────|
绘制       |──────────────────────────[ 显示 ]|

1. 页面切换

2. <img> 先被挂载到 DOM

3. 但因为是 lazy：
  - 浏览器：“先等等，看你是不是真的要显示”

4. 一小会儿后：
  - 才开始 请求
  - 再 解码
  - 最后 绘制

问题就在这里：
DOM 已经在了
但图片还没准备好
→ 用户看到空白 / 闪一下
```

- priority 是「先图片，后 DOM」
```
时间 ─────────────────────────────────────────▶

请求       |──[ 请求 / 读缓存 ]────────────────|
解码       |──────[ 解码 ]─────────────────────|
DOM 挂载   |────────────[ img 插入 DOM ]───────|
绘制       |───────────────[ 立即显示 ]────────|

发生了什么？

1. 页面开始切换
2. 浏览器在 HTML 解析阶段
3. 就把图片加入 高优先级下载队列
    图片： 要么已经在缓存 要么正在下载 + 解码
4. React 把 <img> 插入 DOM 的那一刻： 图片 已经 ready

结果：
1.DOM 出现 = 图片立刻显示
2.→ 没有任何空窗期
3.→ 不闪
```

缓存 ≠ 可立即显示

即使图片已经缓存：

1. lazy： 解码是延迟的
2. priority： 解码是提前的

而闪动，就发生在“DOM 在，但图片没准备好”的那一小段时间里

## 问题2: 为啥配置了pwa 也缓存不到
```js
    // 只缓存静态资源和用户内容，避免预缓存问题
    runtimeCaching: [
      // Cloudflare Images（无后缀图片）
      {
        urlPattern: /^https:\/\/imagedelivery\.net\/.*/i,
        // handler: "CacheFirst",
        handler: "NetworkFirst",
        options: {
          cacheName: "cloudflare-images",
          expiration: {
            maxEntries: 200,
            maxAgeSeconds: 60 * 60 * 24 * 30,
          },
          cacheableResponse: {
            statuses: [0, 200],
          },
        },
      },
    ]
```

```
你的 Cloudflare Images 之所以“怎么配都不进 Cache Storage”，
原因只有一个：
👉 这张图已经被浏览器的 HTTP cache 吃掉了，
Service Worker 从头到尾【一次 fetch 机会都没拿到】。
```

一旦浏览器层已经命中过：

* memory cache
* disk cache
* Cloudflare 的 immutable 强缓存

👉 SW 永远不可能再缓存这条 URL

## 这是浏览器的硬规则（不是 Workbox bug）
请求真实路径是这样的

```
页面加载
  ↓
Chrome HTTP Cache（memory / disk）
  ↓（命中，直接返回）

❌ fetch 事件不触发

❌ Service Worker 完全不知道

❌ runtimeCaching 永远不执行
```

🔍 为什么你线上一定会中这个坑（Cloudflare Images 特别容易）
```
cache-control: public, max-age=31536000, immutable
```

结果是：

- 首次访问（甚至在你上线前）

- Chrome 已经把这张图存进 HTTP cache

- 后续所有访问：
  - 直接内存命中
  - 连 network 都不走
  - SW 没机会

👉 所以你现在看到的现象是必然的


## 304 到底发生了什么？
当你切换页面时：

1. `<img>` 重新挂载

2. 浏览器发现：
  - 这个 URL 以前请求过
  - 本地有缓存

3. 浏览器发送一个 条件请求：
```
If-None-Match / If-Modified-Since

CDN 回复：
304 Not Modified
```

5. 浏览器直接复用 本地磁盘/内存缓存

### 这对性能有没有影响？
网络层面,Cloudflare 这种 CDN 更是秒回。
```
| 项目   | 影响        |
| ---- | --------- |
| 带宽   | 几乎 0      |
| 下载时间 | 0         |
| TTFB | 极低（几十 ms） |
```

性能指标层面（LCP / CLS）
❌ 不会影响 LCP（首次加载）

LCP 只统计 首次进入页面，
路由切换不算。

❌ 不会显著影响 CLS

CLS 是布局偏移，
304 只是确认缓存。

### 为什么你“感觉有影响”？（关键）
❗ 你看到的不是“慢”，是“闪”,即使图片 0ms 加载，也会闪

真正流程是：
```
Image 卸载
↓
DOM 重新插入
↓
浏览器重新解码 / 绘制
↓
你看到一闪
```

### 什么时候“重新请求”才有问题？
只有这 3 种情况才是真问题：

1. ❌ 1️⃣ 200 OK（重新下载
2. ❌ 2️⃣ cache-control 配置错误,Cache-Control: no-store
3. URL 每次变（致命）

### 304 是浏览器在帮你省流量，不是问题本身
你要解决的是“DOM 生命周期”，不是“请求次数”

如果你愿意，下一步我可以：

帮你判断 哪张图必须 Layout 常驻

