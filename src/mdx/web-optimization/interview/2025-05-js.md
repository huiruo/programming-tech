## 基本数据类型
- string: 存储在堆, 地址在栈
_ number:NaN 表示非数值（Not a Number），它是一个特殊的数值，用于表示无法表示为数字的值，可以赋值给 number 类型的变量来表示空值,但它的值不等于任何数，包括它本身。因此，在进行 NaN 和其他值的比较时，结果总是返回 false。
boolean
- null: 表示一个被明确赋值为“空值”的对象
- undefined:表示一个声明了但未被明确赋值的变量，或者访问对象属性时不存在的属性
- symbol:每一个symbol值都是一个全局唯一的字符串，你永远不会知道它里面存的什么，symbol值可以作为对象的属性的键
- Function
- Array
- Set
- Map

## prototype指向属于该函数的原型对象
https://programming-tech.pages.dev/jsBase/prototype

prototype(原型)是函数才有的,指向属于该函数的原型对象,储存着对象的属性和构造函数constructor,在原型对象里有共有的方法，所有构造函数声明的实例都可以共享这个方法。

说明：函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型,也就是这个例子中的 person1 和 person2 的原型。
```js
function Person(){};

Person.prototype.name = 'name';

const person1 = new Person();
const person2 = new Person();

console.log('1:',person1.name) // 1: name
console.log('2:',person2.name) // 2: name
console.log('3:',person2.prototype) // 3: undefined
console.log('4:',person1 instanceof Person) // 4: true

console.log('5:',Person.prototype) // 5: {name: 'name', constructor: ƒ}
console.log('6:',person1.constructor) // 6: ƒ Person(){}

// 重点：true,说明原型链的查找规则
console.log('7',person1.__proto__ === Person.prototype)
```

原型链:查找规则是向隐式原型__proto__一层层查找
原型链是 js 对象的一种链表结构,__proto__是连接每个对象的节点。
```
当寻找一个属性先从本对象找，然后是myA.__proto__=== A.prototype，然后是冒泡往原型链寻找A.prototype.__proto__===Object.prototype,...,最后的原型链的终点:Object.prototype.proto__ -->null
```
个人认为，prototype它在原型链实现中只是起到了一个辅助作用，换言之，它只是在new的时候有着一定的价值，而原型链的本质，其实在于_proto_.

```
原型链的终点:Object.prototype.__proto__ -->null
```
```js
function A() {}
A.prototype.aPrototype='test';

var myA = new A()
myA.test = 1

console.log("a-1-0", A.prototype.__proto__);

console.log("myA:", myA);

// 注意点：:A的原型的构造函数指向自己: // ƒ A()
console.log("a-1.prototype.constructor", A.prototype.constructor);

// 指向 Object.prototype
console.log("a-1-0", A.prototype.__proto__);
// true
console.log(A.prototype.__proto__ === Object.prototype)

// ƒ Object() { [native code] } 
console.log("a-1-1", A.prototype.__proto__.constructor);

// ƒ () { [native code] } --> Object是Function的实例对象
console.log("a-1-1", A.prototype.__proto__.constructor.__proto__);

// true
console.log("a-2.是否等", A.prototype.constructor === A);

// undefined 注意：这样访问aPrototype
console.log("0-2.aPrototype:", A.aPrototype);
```

## 函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次
- 防抖的目的即是为了拿到最终的结果，所以前面不管触发多少次，我们都可以不管，只等到它不再触发了才做最后的处理。将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

- 而节流是对相同事件的触发频率的控制，它触发的次数不会造成不同的结果

## 3.Event loop是一种机制，用于协调和处理不同线程之间的任务和事件
为了解决单线程的阻塞问题，加了一层调度逻辑，也就是 Loop 循环和 Task 队列，把阻塞的逻辑放到其他线程跑，从而支持了异步。然后为了支持高优先级的任务调度，又引入了微任务队列,这就是浏览器的 Event Loop 机制：每次执行一个宏任务，然后执行所有微任务。
```
当JavaScript引擎执行完一个宏任务后，会首先处理所有当前微任务队列中的微任务，然后再继续执行下一个宏任务。这确保了微任务的优先级高于宏任务，从而可以更快地响应一些重要操作，例如Promise的处理结果。
```

JavaScript 用于写网页交互逻辑为了避免多线程同时修改dom的同步问题设计成了单线程。浏览器要负责多个任务，如渲染HTML、执行JavaScript代码、处理用户交互（用 户输入、鼠标点击等）、执行和处理异步请求。

在前端开发中，JavaScript 代码通常在主线程中执行。当执行异步操作（例如网络请求、定时器、事件处理器等）时，结果将被发送到事件队列中。然后，"Event loop" 负责按照一定的顺序将这些结果处理，并在主线程上执行相应的回调函数。

首先执行同步代码，这属于宏任务,执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
先执行"最前面"的宏任务, 当执行完所有同步代码后，执行栈为空，立即执行当前微任务队列中的所有微任务（依次执行）,所有微任务完毕之后, 进入下一次 loop, 执行接下来的宏任务, 重复上述过程。

### 宏任务是由浏览器或Node.js环境提供的任务队列，它们会在主线程空闲时执行。以下是常见的宏任务：
1. setTimeout 和 setInterval：在指定的时间间隔或延迟之后执行指定的函数。
特点:setTimeout定义的操作在函数调用栈清空之后才会执行

2. 网络请求：执行网络请求（如HTTP请求）,通常通过XMLHttpRequest或fetch等方式异步获取数据的操作。

3. 页面渲染：在页面加载、重绘或者样式计算时执行的任务。解析和渲染：解析HTML、CSS以及构建和渲染DOM树和页面布局等任务通常也作为宏任务执行。

4. UI 交互事件：如点击、鼠标移动、滚动、输入等，触发了事件处理，这些事件通常作为宏任务执行。。

5. 原生事件：例如window.resize、window.scroll等。

6. requestAnimationFrame：用于执行动画的requestAnimationFrame方法会触发回调函数，这个回调函数作为宏任务执行，通常在每个屏幕刷新之前执行。

7. postMessage：通过MessageChannel或window.postMessage方法发送的异步消息。

8. 文件I/O（Node.js环境）：在Node.js环境中，文件I/O操作通常是宏任务，涉及读取或写入文件系统。

### 微任务有哪些？
微任务是 JavaScript 引擎内部的任务，会在当前宏任务执行完毕后立即执行。
微任务会在当前宏任务执行完毕后，优先于下一个宏任务执行，因此可以用来在当前任务完成后立即执行一些需要尽早完成的任务，例如执行一些 DOM 更新操作，避免用户看到页面更新的延迟感。需要注意的是，由于微任务在执行顺序上的优先级比较高，如果不小心出现过多的微任务，可能会导致宏任务长时间得不到执行，从而导致页面卡顿的现象。

1. Promise:new Promise().then 的回调,首先Promise构造函数会立即执行，而Promise.then()内部的代码在当次事件循环的结尾立即执行(微任务)。
2. async/await：使用async函数和await操作符时，await之后的代码会被放入微任务队列中，以在Promise状态发生变化时执行。
3. Vue nextTick  参考：api-nextTick


## CommonJS 和 ES Modules 有什么区别？
| 特性                    | CommonJS                       | ES Modules (ESM)          |
| --------------------- | ------------------------------ | ------------------------- |
| **使用方式**              | `require()` / `module.exports` | `import` / `export`       |
| **加载方式**              | **同步加载**（运行时加载）                | **异步加载**（编译时静态分析）         |
| **是否动态引入支持好**         | 支持动态引入（`require(...)`）         | `import()` 是动态导入方法        |
| **是否支持 Tree-shaking** | ❌ 不支持                          | ✅ 支持                      |
| **适用环境**              | Node.js（传统）                    | 浏览器、现代 Node.js（支持 `.mjs`） |
| **模块解析时间点**           | 运行时                            | 编译时                       |
| **默认导出机制**            | `module.exports = value`       | `export default value`    |
| **顶层 await 支持**       | ❌ 不支持                          | ✅ 支持                      |


| 问题                          | 回答                                                          |
| --------------------------- | ----------------------------------------------------------- |
| CommonJS 和 ESModules 最大的区别？ | 一个是同步（运行时），一个是静态（编译时），语法不同，机制不同                             |
| Webpack 打包后是 CommonJS 吗？    | **不是纯粹的 CommonJS 或 ESM**，而是 Webpack 自己实现的模块系统（除非你显式配置输出为模块） |
| Webpack 能打成 ESM 吗？          | ✅ 可以，Webpack 5 以后通过配置 `output.module = true` 支持打成 ESModule  |

### Webpack 打包的 JS 是什么？
Webpack 默认会把你写的模块（无论是 CommonJS 还是 ES Module）转成一种统一的模块格式，供浏览器运行。

Webpack 本身使用 CommonJS 写法开发

Webpack 打包输出默认是 IIFE（立即执行函数）形式，并模拟模块系统

```js
(function(modules) {
  // webpack bootstrap 模块运行时模拟
})([
  /* 模块数组 */
])
```

## 如何处理前端大文件上传与断点续传？
使用 Blob.slice 分片；

控制并发数量；

使用唯一 hash 标识文件；

后端记录上传进度；

合并分片接口。