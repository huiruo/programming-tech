
##  页面加载过程中发生了什么？详细描述浏览器的渲染流程。
- DNS 解析

- TCP 连接（三次握手）

- 请求 HTML

- 解析 HTML -> 构建 DOM

- 下载 CSS -> 构建 CSSOM

- DOM + CSSOM -> Render Tree

- Layout（回流）

- Paint（重绘）

- Composite（合成图层）

## 什么情况下会发生重排和重绘？如何优化？
重排：影响布局，如 width, height, display；

重绘：只影响外观，如 color, background；

优化：使用 transform/opacity 替代位置和大小、合并 DOM 操作、使用 will-change。

## 如何提升页面首次加载速度（首屏优化）？
- SSR / SSG；

- 图片懒加载；

- 预加载关键资源；

- 减少首屏 JS 包体积；

- 使用 HTTP/2。

## react 懒加载
你使用的是 Intersection Observer API 实现懒加载的“可视区域检测”。它的核心机制是：

- 浏览器提供 IntersectionObserver API，可以侦测某个 DOM 元素是否进入了视口。

- 当图片容器进入视口（或距离视口一定范围）时：
  - 你设置 setIsVisible(true)
  - 再根据 isVisible === true 条件渲染`<Image />`
  - 此时 next/image 组件才会插入 DOM，才会发起网络请求去加载图片资源。
```js
export const GameItem = ({ item, isFavorite = false, isLoading, onPlayGame, onFavoriteCallback }: GameItemProps) => {
  const [loaded, setLoaded] = useState(false)
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  const iconUrl = isAbsoluteUrl(item.icon)
    ? item.icon
    : `${ImageBaseUrl}${item.icon}/public`;

  useEffect(() => {
    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            setIsVisible(true);       // 🔥 标记元素已进入视口
            observer.disconnect();    // 🚫 断开监听，节省性能
          }
        });
      },
      { rootMargin: "100px" }         // 👀 提前 100px 触发
    );

    if (ref.current) {
      observer.observe(ref.current);  // 👇 开始观察元素
    }

    return () => observer.disconnect();
  }, []);

  return <div
    ref={ref}
    onClick={() => onPlayGame(item.id)}
    className="relative min-h-[140px] w-full cursor-pointer"
  >
  </div>
}
```

✅ 相比`<img loading="lazy" />`有什么优点？

| 特性        | IntersectionObserver | `<img loading="lazy" />` |
| --------- | -------------------- | ------------------------ |
| 控制粒度      | 完全可控（可自定义距离、回调、行为）   | 浏览器控制，黑盒                 |
| 支持度       | 所有现代浏览器              | Safari 不支持或部分版本兼容性差      |
| 可结合动画/骨架屏 | ✅ 完全支持               | ❌ 无法精细控制 DOM 插入时机        |
| 可控制资源插入时机 | ✅ 进入视口再插入资源          | ❌ 图片标签已在 DOM 中时即开始加载     |

## 虚拟列表组件库的实现原理-对比瀑布流
虚拟列表库（比如 react-virtual, react-window, react-virtualized）不是靠“懒加载图片”，而是从根本上只渲染可视区域的 DOM 节点：

| 名称                                                                  | 特点               | 链接      |
| ------------------------------------------------------------------- | ---------------- | ------- |
| [`react-virtual`](https://github.com/tannerlinsley/react-virtual)   | 现代、小巧、Hooks API  | ⭐ 推荐    |
| [`react-window`](https://github.com/bvaughn/react-window)           | Facebook 出品，性能极致 | ⭐       |
| [`react-virtualized`](https://github.com/bvaughn/react-virtualized) | 功能最全（表格/树/列表）但较重 | ✅ 大型项目用 |

| 特点                   | 描述                                       |
| -------------------- | ---------------------------------------- |
| 🚫 不渲染视口外元素          | 视口外的组件/图片完全不挂载 DOM，节省内存与计算               |
| 🧮 精确计算 offset       | 组件只渲染比如当前 10 个 item（+前后 buffer），其余只占空白高度 |
| ♻️ DOM 节点复用          | 滚动时原节点复用，不新建 DOM，极低重排重绘成本                |
| ✅ 完全自控渲染节奏           | 比 `IntersectionObserver` 控制更细、更强         |
| ⛔ 不能配合 `grid` 宽高不定布局 | 多列瀑布流不适合，需要配合特殊插件                        |

核心区别：你当前做法 vs 虚拟列表库
| 比较点        | 你现在用的方式                   | 虚拟列表组件库                       |
| ---------- | ------------------------- | ----------------------------- |
| 是否挂载全部 DOM | ✅ 全挂载，只控制图片加载             | ❌ 只挂载一小段视口内的 DOM              |
| 图片加载控制     | 使用 `IntersectionObserver` | 控制在是否渲染 DOM 内部处理              |
| 性能瓶颈       | DOM 节点太多会变卡               | 节点数始终保持很少，极省资源                |
| 适合场景       | 图片墙、媒体卡片等                 | 聊天框、表格、列表、高频滚动                |
| 使用难度       | 简单，现成 Image + Skeleton 即可 | 复杂，需要计算 offset、scrollHeight 等 |

🧪 举例：虚拟列表库应用场景
| 场景               | 推荐方案                        |
| ---------------- | --------------------------- |
| 上下滚动的 IM 聊天记录    | ✅ 使用虚拟列表（如 `react-virtual`） |
| 数千条用户评论          | ✅ 虚拟列表                      |
| 网页版图库、游戏墙（含卡片交互） | ✅ 你现在的方式更合适                 |
| 瀑布流 + 不等高图片      | ❌ 虚拟列表不适合（除非你自己实现复杂布局计算）    |


# 🔐 安全与攻防
CSRF 与 XSS 的区别与防护方案？

| 项目 | CSRF              | XSS            |
| -- | ----------------- | -------------- |
| 本质 | 利用 Cookie 自动发送    | 注入恶意脚本执行       |
| 防护 | Token 校验、SameSite | 输入转义、CSP、内容白名单 |

## 有 100 万条数据，要求渲染 + 搜索，如何优化？
- 虚拟滚动（如 react-window）；
- 使用 Web Worker 处理搜索逻辑；
- 节流 / 分批加载 DOM；
- 索引关键字做预检。
