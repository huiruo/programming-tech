## Socks5
Socks5是属于TCP/IP模型中应用层的协议，因此，网络连接过程可以理解基于Socks5协议的请求由客户机到代理机的整个过程如下：
* 将用户数据添加SOCKS5头部，发到传输层；
* 传输层将SOCKS5协议数据分段，添加TCP/UDP协议数据发到网络层；
* 网络层将TCP/UDP协议数据添加IP协议头，发往链路层；
* 链路层添加帧头与尾，将数据封装成帧发往代理机。

## Socks5工作原理
```
Socks5客户端 <---socks5---> Socks5服务器 <—正常请求—> 目标主机
```

Socks5客户端在与Socks5服务器交互的整个过程是有可能暴露在整个互联网中的，因此很容易被监控到，根据协议特征也可以很容易识别出来。

## Shadowsocks Socks5工作原理
```
Socks5客户端 <---socks5---> sslocal <–密文–> ss-server <—正常请求—> 目标主机
```
Shadowsocks的处理方式是将Socks5客户端与Socks5服务器的连接提前，Socks5协议的交互完全是在本地进行的，在网络中传输的完全是利用加密算法加密后的密文，这就很好的进行了去特征化，使得传输的数据不是很容易的被特征识别。

## 差异部分：
* 本地的sslocal：sslocal对于Socks5客户端便是Socks5服务器,对于Socks5客户端是透明的，sslocal完成与Socks5客户端所有的交互。
* 远程的ssserver：ssserver对于目标主机同样也是Socks5服务器，对于目标主机是透明的，完成Socks5服务器与目标主机的所有操作。
* sslocal-ssserver:sslocal接收到Socks5客户端发送的数据，会将数据加密，并将配置信息发送到ssserver，ssserver接收到配置信息进行权限验证，然后将数据进行解密，然后将明文发往目标主机；当目标主机响应ssserver，ssserver将接收到的数据进行解包，并将数据加密，发送到sslocal，sslocal接收到加密后的数据进行解密，再发送给Socks 5客户端，这就完成了一次交互。

## SOCKS工作在比HTTP代理更低的层次：
`HTTP代理只是将HTTP请求转发到所需的HTTP服务器`

SOCKS使用握手协议来通知代理软件其客户端试图进行的连接SOCKS，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头（例如，使用另一种底层协议，例如FTP；然而，HTTP代理只是将HTTP请求转发到所需的HTTP服务器）。


虽然HTTP代理有不同的使用模式，CONNECT方法允许转发TCP连接； HTTP代理通常更了解HTTP协议，执行更高层次的过滤（虽然通常只用于GET和POST方法，而不用于CONNECT方法）。

然而，SOCKS代理还可以转发UDP流量和反向代理，而HTTP代理不能。

## 例子：
* SOCKS：Bill希望通过互联网与Jane沟通，但他们的网络之间存在一个防火墙，Bill不能直接与Jane沟通。所以，Bill连接到他的网络上的SOCKS代理，告知它他想要与Jane创建连接；SOCKS代理打开一个能穿过防火墙的连接，并促进Bill和Jane之间的通信。

* HTTP：Bill希望从Jane的Web服务器下载一个网页。Bill不能直接连接到Jane的服务器，因为在他的网络上设置了防火墙。
为了与该服务器通信，Bill连接到其网络的HTTP代理。他的网页浏览器与代理通信的方式与他直接连接Jane的服务器的方式相同；也就是说，网页浏览器会发送一个标准的HTTP请求头。HTTP代理连接到Jane的服务器，然后将Jane的服务器返回的任何数据传回Bill。


## SS全称是Shadowsocks，是一种基于Socks5代理方式的加密传输协议。
特点:
```
1.Shadowsocks使用自行设计的协议进行加密通信。加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，无需保持“一直连线”的状态，因此在移动设备上相对较为省电。

2.所有的流量都经过算法加密，允许自行选择算法。

3.Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。
```

Shadowsocks由两部分组成，客户端和服务器端。 在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。

```
客户端启动后会开启一个本地代理（一般用HTTP Proxy），通过修改操作系统配置或者浏览器配置把访问请求转发给本地代理。

当我们通过浏览器访问某个地址的时候:
	第一步：数据会被转发到本地代理.
	第二步：由本地代理加密后转发到服务器端.
	第三部：服务器端处理完请求后把数据加密后返回给客户端的本地代理.
	第四步：本地代理再次返回给浏览器。
```

```
1. SS协议和Http Proxy、Socks5没有关系，Http Proxy、Socks5这两个协议是浏览器或者操作系统所支持的标准代理协议，SS的架构中只是用这两种协议作为“获取用户请求”的手段而已。
2. SS协议中没有任何控制流，本地代理获取用户原始TCP/UDP数据包获取之后会直接取出Data部分，重新构造一个IP数据包（可能是TCP或者UDP，和用户原始请求是TCP还是UDP有关系。），目标地址和端口是服务器地址，数据包的Data部分是加密后的用户原始Data。
```

## SS安全性与加密
```
SS中本地代理和服务器通讯数据包都是经过加密的，DPI（深度数据包检测）只能检测到IP头部和TCP/UDP头部，无法对内容进行检测，而VPN之类的就特别容易被检测到了。想检测SS只能通过“流量特征”（数据包的结构）推测，但是使用SS一般选择带IV模式的AES加密算法作为加密方法（不了解AES的朋友请参考公众号的《深入浅出AES加密》），利用IV对数据做随机化，使每次请求的数据包都不一样，一般很难形成“流量特征”。如果SS无法使用那么一定是由于服务器端IP地址被限制了，被限制的原因也绝对不是由于SS被识别到了（除非谁有通天的能耐破解AES）。
```

## Shadowsocks数据包分析
```
前三条是TCP握手我们无视后面是162字节的请求数据包，接着是服务器端回复一个ACK确认（60）字节，接着是服务器返回651字节的回复数据包；紧接着服务器发送60字节的TCP控制数据包扩大数据窗口；客户端回复54字节的ACK确认数据包。后面4条是TCP的关闭动作。

我们关注的重点是162字节的请求和651字节的回复是什么内容：
SS请求数据包
关注IP头部和TCP头部，这两部分信息是源地址是本地代理的IP地址和端口；目标地址是服务器端的IP地址和端口，Data部分108字节是通过AES加密的原始请求。
```
## SS回复数据包
```
这是SS服务器回复给本地代理的数据包。IP和TCP头部没有什么特殊的，直接看Data部分，一共597字节。也是加密后的数据，我们把它解出来。
服务器端没有增加特殊头部，直接把原始数据返回。

```

## SS改进
```
SS的设计很low（好吧，其实也没啥设计），效率也很差，特别是HTTP之类的短连接简直是灾难。一个Web页面中可能包含40-50个请求那么相当于SS中转40-50次，所以并发压力很大。但是它实现起来特别简单，而且行之有效，这也许就是它美妙的地方。
```