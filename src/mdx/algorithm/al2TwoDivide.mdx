import CodeBlock from '../../components/codeBlock';
import CodePannel from '../CodePannel';

export const testCode = `
const MAX = 2147483647, MIN = -2147483648;

var divide = function(dividend, divisor) {
    // 处理特殊情况：被除数为最小负数且除数为-1，会溢出，返回INT_MAX
    if (dividend === MIN && divisor === -1)
        return MAX;
    
    // 取被除数和除数的绝对值，因为我们只关心它们的大小关系
    let a = Math.abs(dividend), b = Math.abs(divisor), res = 0;

    // 从高位到低位遍历，找到最大的倍数使得被除数仍大于等于除数
    for (let i = 31; i >= 0; i--) {
        if ((a >>> i) >= b) {
            // 如果当前倍数大于等于被除数，则减去对应的值，并将倍数加到结果中
            if (i === 31) {
                // 特殊处理：防止溢出
                a -= MAX;
                a -= 1;
                res -= MIN;
            } else {
                a -= b << i;
                res += 1 << i;
            }
        }
    }

    // 根据被除数和除数的符号确定最终结果的符号
    return (dividend > 0) === (divisor > 0) ? res : -res;
};


// 示例测试
console.log(divide(10, 3)); // 输出: 3
console.log(divide(7, -3)); // 输出: -2
`

给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。

返回被除数 dividend 除以除数 divisor 得到的 商 。

注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。

<CodeBlock>
```text
示例 1:

输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = 3.33333.. ，向零截断后得到 3 。
示例 2:

输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = -2.33333.. ，向零截断后得到 -2 。
```
</CodeBlock>
js解法并注释,解析用什么算法解决问题,并说明时间复杂度

[description](https://leetcode.cn/problems/divide-two-integers/description/)

<CodePannel code={testCode} height='650px'/>

## 解析
## 这个问题可以使用位运算（位移操作）来解决，通常使用二分查找的思想。
这段代码首先处理了特殊情况，即被除数为最小负数且除数为-1时，返回INT_MAX，以避免溢出。然后，它取被除数和除数的绝对值，因为我们只关心它们的大小关系，不关心符号。

接下来，它从高位到低位遍历，找到最大的倍数，使得被除数仍大于等于除数。在每一次循环中，它使用位运算来判断是否可以减去当前倍数，并将倍数累加到结果中。

最后，根据被除数和除数的符号确定最终结果的符号，返回正确的商。这段代码对边界情况和溢出进行了特殊处理，确保了正确的结果。


这段代码使用了一种基于二进制位运算的算法，它是一种类似于二分查找的方法，被称为 "二进制翻倍法" 或 "位运算除法"。算法的基本思想是通过迭代从高位到低位，不断找到最大的倍数，使得被除数仍然大于等于除数，然后将这个倍数累加到结果中。这个过程重复进行，直到不能再找到符合条件的倍数。

具体步骤如下：

1. 通过位运算判断被除数的高位是否大于等于除数。
2. 如果高位大于等于除数，就找到最大的倍数（使用左移位操作）使得被除数仍然大于等于除数。
3. 减去对应的值，并将这个倍数累加到结果中。
4. 重复上述步骤，直到所有位都处理完毕。

这个算法的关键在于利用二进制位运算的性质，可以高效地进行除法操作，而且对于特殊情况进行了额外的处理，以避免溢出。这个算法的时间复杂度是 O(32)，因为有 32 位整数，所以它的时间复杂度是常数级别的，非常高效。